package org.jets3t;

import java.io.UnsupportedEncodingException;
import java.util.HashMap;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class GETRequestSigner {
	private static final String US_AWS_ENDPOINT = "s3.amazonaws.com";
	private static final String AWS_REST_HEADER_PREFIX = "x-amz-";

	private static Logger log = LoggerFactory.getLogger(GETRequestSigner.class);
	private String AWSAccessKeyId;
	private String AWSSecret;

	public GETRequestSigner(String AWSAccessKeyId, String AWSSecret) {
		this.AWSAccessKeyId = AWSAccessKeyId;
		this.AWSSecret = AWSSecret;
	}

	/**
	 * Generates a signed URL string that will grant access to an S3 resource
	 * (bucket or object) to whoever uses the URL up until the time specified.
	 * 
	 * @param method
	 *            the HTTP method to sign, such as GET or PUT (note that S3 does
	 *            not support POST requests).
	 * @param bucketName
	 *            the name of the bucket to include in the URL, must be a valid
	 *            bucket name.
	 * @param objectKey
	 *            the name of the object to include in the URL, if null only the
	 *            bucket name is used.
	 * @param specialParamName
	 *            the name of a request parameter to add to the URL generated by
	 *            this method. 'Special' parameters may include parameters that
	 *            specify the kind of S3 resource that the URL will refer to,
	 *            such as 'acl', 'torrent', 'logging', or 'location'.
	 * @param headersMap
	 *            headers to add to the signed URL, may be null. Headers that
	 *            <b>must</b> match between the signed URL and the actual
	 *            request include: content-md5, content-type, and any header
	 *            starting with 'x-amz-'.
	 * @param secondsSinceEpoch
	 *            the time after which URL's signature will no longer be valid.
	 *            This time cannot be null. <b>Note:</b> This time is specified
	 *            in seconds since the epoch, not milliseconds.
	 * @param isVirtualHost
	 *            if this parameter is true, the bucket name is treated as a
	 *            virtual host name. To use this option, the bucket name must be
	 *            a valid DNS name that is an alias to an S3 bucket.
	 * @param isHttps
	 *            if true, the signed URL will use the HTTPS protocol. If false,
	 *            the signed URL will use the HTTP protocol.
	 * @param isDnsBucketNamingDisabled
	 *            if true, the signed URL will not use the DNS-name format for
	 *            buckets eg. <tt>jets3t.s3.amazonaws.com</tt>. Unless you have
	 *            a specific reason to disable DNS bucket naming, leave this
	 *            value false.
	 * 
	 * @return a URL signed in such a way as to grant access to an S3 resource
	 *         to whoever uses it.
	 * 
	 * @throws S3ServiceException
	 * @throws UnsupportedEncodingException
	 */
	private String createSignedUrl(String method, String bucketName,
			String objectKey, String specialParamName,
			Map<String, Object> headersMap, long secondsSinceEpoch,
			boolean isVirtualHost, boolean isHttps,
			boolean isDnsBucketNamingDisabled) throws S3ServiceException,
			UnsupportedEncodingException {
		try {
			String s3Endpoint = US_AWS_ENDPOINT;
			String uriPath = "";

			String hostname = (isVirtualHost ? bucketName : S3Utils
					.generateS3HostnameForBucket(bucketName,
							isDnsBucketNamingDisabled, s3Endpoint));

			if (headersMap == null) {
				headersMap = new HashMap<String, Object>();
			}

			// If we are using an alternative hostname, include the
			// hostname/bucketname in the resource path.
			String virtualBucketPath = "";
			if (!s3Endpoint.equals(hostname)) {
				int subdomainOffset = hostname.lastIndexOf("." + s3Endpoint);
				if (subdomainOffset > 0) {
					// Hostname represents an S3 sub-domain, so the bucket's
					// name is the CNAME portion
					virtualBucketPath = hostname.substring(0, subdomainOffset)
							+ "/";
				} else {
					// Hostname represents a virtual host, so the bucket's name
					// is identical to hostname
					virtualBucketPath = hostname + "/";
				}
				uriPath = (objectKey != null ? S3Utils.encodeUrlPath(objectKey,
						"/") : "");
			} else {
				uriPath = bucketName
						+ (objectKey != null ? "/"
								+ S3Utils.encodeUrlPath(objectKey, "/") : "");
			}

			if (specialParamName != null) {
				uriPath += "?" + specialParamName + "&";
			} else {
				uriPath += "?";
			}

			uriPath += "AWSAccessKeyId=" + AWSAccessKeyId;
			uriPath += "&Expires=" + secondsSinceEpoch;

			// Include Requester Pays header flag, if the flag is included as a
			// request parameter.
			if (specialParamName != null
					&& specialParamName.toLowerCase().indexOf(
							Constants.REQUESTER_PAYS_BUCKET_FLAG) >= 0) {
				String[] requesterPaysHeaderAndValue = Constants.REQUESTER_PAYS_BUCKET_FLAG
						.split("=");
				headersMap.put(requesterPaysHeaderAndValue[0],
						requesterPaysHeaderAndValue[1]);
			}

			String serviceEndpointVirtualPath = "";

			String canonicalString = S3Utils.makeServiceCanonicalString(method,
					serviceEndpointVirtualPath + "/" + virtualBucketPath
							+ uriPath, S3Utils.renameMetadataKeys(headersMap),
					String.valueOf(secondsSinceEpoch), AWS_REST_HEADER_PREFIX,
					S3Utils.getResourceParameterNames());

			log.info("Signing canonical string:\n" + canonicalString);

			String signedCanonical = S3Utils.signWithHmacSha1(AWSSecret,
					canonicalString);
			String encodedCanonical = S3Utils.encodeUrlString(signedCanonical);
			uriPath += "&Signature=" + encodedCanonical;

			if (isHttps) {
				return "https://" + hostname + serviceEndpointVirtualPath + "/"
						+ uriPath;
			} else {
				return "http://" + hostname + serviceEndpointVirtualPath + "/"
						+ uriPath;
			}
		} catch (ServiceException se) {
			throw new S3ServiceException(se);
		}
	}

	/**
	 * Generates a signed URL string that will grant access to an S3 resource
	 * (bucket or object) to whoever uses the URL up until the time specified.
	 * 
	 * @param method
	 *            the HTTP method to sign, such as GET or PUT (note that S3 does
	 *            not support POST requests).
	 * @param bucketName
	 *            the name of the bucket to include in the URL, must be a valid
	 *            bucket name.
	 * @param objectKey
	 *            the name of the object to include in the URL, if null only the
	 *            bucket name is used.
	 * @param specialParamName
	 *            the name of a request parameter to add to the URL generated by
	 *            this method. 'Special' parameters may include parameters that
	 *            specify the kind of S3 resource that the URL will refer to,
	 *            such as 'acl', 'torrent', 'logging' or 'location'.
	 * @param headersMap
	 *            headers to add to the signed URL, may be null. Headers that
	 *            <b>must</b> match between the signed URL and the actual
	 *            request include: content-md5, content-type, and any header
	 *            starting with 'x-amz-'.
	 * @param secondsSinceEpoch
	 *            the time after which URL's signature will no longer be valid.
	 *            This time cannot be null. <b>Note:</b> This time is specified
	 *            in seconds since the epoch, not milliseconds.
	 * 
	 * @return a URL signed in such a way as to grant access to an S3 resource
	 *         to whoever uses it.
	 * 
	 * @throws S3ServiceException
	 */
	public String createSignedGETUrl(String bucketName, String objectKey,
			long secondsSinceEpoch, boolean isSecure) throws Exception {
		return createSignedUrl("GET", bucketName, objectKey, null, null,
				secondsSinceEpoch, false, isSecure, false);
	}

}
